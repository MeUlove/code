long long q_mi(long long aa,long long bb)    求aa的bb次方
{
	long long tot=1;
	while(bb)
	{
		if(bb&1)tot=tot*aa%k;  
		aa=aa*aa%k;
		bb>>=1;  //bb/=2;    向左位移1位，位运算，速度快
	}
	return tot%k;
}

/*关于 b & 1：
“&”美名曰“按位与”。
x & y 是二进制 x 和 y 的每一位分别进行“与运算”的结果。
与运算，即两者都为 1 时才会返回 1，否则返回 0。
那么 b & 1

          二进制
b     =    1011
1     =    0001
b&1   =    0001

因为 1（二进制）的前面几位全部都是 0，
所以只有 b 二进制最后一位是 1 时，b & 1 才会返回 1。
挺巧妙的，并且很快。)*/
利用二进制的思想：a的11次方，   11---1011 ，11==8+2+1； 然后就乘，每次取平方，在数很大的时候，跑得很快
